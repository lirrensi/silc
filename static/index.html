<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title>SILC terminal GUI</title>

        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css"
        />

        <style>
            body {
                margin: 0;
                padding: 20px;
                background: #1e1e1e;
                font-family: system-ui, sans-serif;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            #terminal {
                /* Fixed-size terminal (no flex/stretch): keep xterm cols/rows stable */
                display: inline-block;
                align-self: center;

                /* If viewport is smaller than the terminal, allow scrolling instead of reflow */
                max-width: 100%;
                max-height: calc(100vh - 100px);
                overflow: auto;

                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            }
            .status {
                color: #ffb3d9;
                text-align: center;
                padding: 8px;
                font-size: 14px;
                background: #2d1b2a;
                border-radius: 8px 8px 0 0;
            }
        </style>
    </head>
    <body>
        <div
            class="status"
            id="status"
        >
            Connecting to WebSocket...
        </div>
        <div id="terminal"></div>

        <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>

        <script>
            // Dynamic port/protocol for WS + HTTP endpoints
            const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
            const httpProtocol = window.location.protocol === "https:" ? "https:" : "http:";
            const host = window.location.hostname;
            const port = window.location.port || "20000"; // fallback if empty
            const wsUrl = `${wsProtocol}//${host}:${port}/ws`;
            const httpBaseUrl = `${httpProtocol}//${host}:${port}`;

            // Create terminal
            // Backend PTY is hard-coded to 120x30, so keep xterm hard-coded the same.
            // Do NOT fit/resize in the browser; instead the container scrolls/clips.
            const term = new Terminal({
                cols: 120,
                rows: 30,
                scrollback: 5000,
                theme: {
                    background: "#1e1e1e",
                    foreground: "#ffffff",
                    cursor: "#ff80bf",
                    selectionBackground: "#ff80bf44",
                },
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                fontSize: 15,
                cursorBlink: true,
            });

            term.open(document.getElementById("terminal"));
            term.focus();

            // WebSocket
            const socket = new WebSocket(wsUrl);
            const statusEl = document.getElementById("status");

            socket.onopen = () => {
                statusEl.textContent = "Connected!";
                statusEl.style.background = "#1b2d1e";
            };

            socket.onmessage = event => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.event === "update") {
                        term.write(msg.data);
                    }
                } catch (e) {
                    // If not JSON, maybe raw data fallback?
                    term.write(event.data);
                }
            };

            socket.onclose = () => {
                statusEl.textContent = "Connection closed :(";
                statusEl.style.background = "#2d1b1b";
                term.write("\r\n\r\n--- WebSocket closed ---\r\n");
            };

            socket.onerror = err => {
                statusEl.textContent = "Connection error :(";
                statusEl.style.background = "#2d1b1b";
                console.error("WebSocket error:", err);
            };

            const sendViaWS = text => {
                if (socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ event: "type", text, nonewline: true }));
                }
            };

            term.onData(data => {
                sendViaWS(data);
            });

            const ctrlcBtn = document.getElementById("ctrlc-btn");
            if (ctrlcBtn) {
                ctrlcBtn.addEventListener("click", () => {
                    sendViaWS("\x03");
                });
            }

            const ctrldBtn = document.getElementById("ctrld-btn");
            if (ctrldBtn) {
                ctrldBtn.addEventListener("click", () => {
                    sendViaWS("\x04");
                });
            }

            document.querySelectorAll(".arrow-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    const key = btn.dataset.key;
                    const keyMap = {
                        up: "\x1b[A",
                        down: "\x1b[B",
                        left: "\x1b[D",
                        right: "\x1b[C",
                    };
                    sendViaWS(keyMap[key]);
                });
            });

            const clearBtn = document.getElementById("clear-btn");
            if (clearBtn) {
                clearBtn.addEventListener("click", async () => {
                    try {
                        await fetch(`${httpBaseUrl}/clear`, { method: "POST" });
                        term.clear();
                    } catch (e) {
                        console.error("Clear failed:", e);
                    }
                });
            }
        </script>
    </body>
</html>
