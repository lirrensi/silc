<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0"
        />
        <title>SILC terminal GUI</title>

        <script src="https://cdn.tailwindcss.com"></script>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css"
        />

        <style>
            body {
                background: #1e1e1e;
            }
            #terminal {
                display: inline-block;
                align-self: center;
                max-width: 100%;
                max-height: calc(100vh - 180px);
                overflow: auto;
                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
                resize: both;
                min-width: 400px;
                min-height: 200px;
            }
            #terminal .xterm-viewport::-webkit-scrollbar {
                display: none;
            }
        </style>
    </head>
    <body class="min-h-screen flex flex-col items-center p-4">
        <div
            class="w-full max-w-5xl text-center py-2 text-pink-300 text-sm bg-[#2d1b2a] rounded-t-xl font-medium"
            id="status"
        >
            Connecting to WebSocket...
        </div>
        <div id="terminal"></div>
        <div class="w-full max-w-5xl bg-[#252526] rounded-b-xl p-4 flex flex-wrap gap-3 justify-center shadow-lg">
            <button
                class="px-4 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all min-w-[60px]"
                id="ctrlc-btn"
            >
                Ctrl+C
            </button>
            <button
                class="px-4 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all min-w-[60px]"
                id="ctrld-btn"
            >
                Ctrl+D
            </button>
            <div class="flex gap-1">
                <button
                    class="arrow-btn px-3 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all"
                    data-key="up"
                >
                    ↑
                </button>
                <button
                    class="arrow-btn px-3 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all"
                    data-key="left"
                >
                    ←
                </button>
                <button
                    class="arrow-btn px-3 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all"
                    data-key="down"
                >
                    ↓
                </button>
                <button
                    class="arrow-btn px-3 py-2 bg-[#3e3e42] border border-[#5e5e62] text-white text-sm font-medium rounded hover:bg-[#5e5e62] hover:border-pink-400 transition-all"
                    data-key="right"
                >
                    →
                </button>
            </div>
            <button
                class="px-4 py-2 bg-red-600 border border-red-400 text-white text-sm font-medium rounded hover:bg-red-400 transition-all min-w-[60px]"
                id="clear-btn"
            >
                Clear
            </button>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/lib/xterm.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@xterm/addon-unicode11@0.9.0/lib/addon-unicode11.js"></script>

        <script>
            (async function () {
                const wsProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
                const httpProtocol = window.location.protocol === "https:" ? "https:" : "http:";
                const host = window.location.hostname;
                const port = window.location.port || "20000";
                const statusEl = document.getElementById("status");
                const urlParams = new URLSearchParams(window.location.search);
                const tokenParam = urlParams.get("token");
                const httpBaseUrl = `${httpProtocol}//${host}:${port}`;

                const fetchTokenFromServer = async () => {
                    try {
                        const resp = await fetch(`${httpBaseUrl}/token`, {
                            cache: "no-store",
                        });
                        if (!resp.ok) {
                            return undefined;
                        }
                        const data = await resp.json();
                        return data.token ?? null;
                    } catch (err) {
                        return undefined;
                    }
                };

                let token = tokenParam;
                let tokenResolved = tokenParam !== null;

                if (!tokenResolved) {
                    const serverToken = await fetchTokenFromServer();
                    if (serverToken !== undefined) {
                        token = serverToken;
                        tokenResolved = true;
                    }
                }

                if (!token && !tokenResolved) {
                    token = window.prompt("Enter the SILC session token:");
                }

                if (!token && !tokenResolved) {
                    statusEl.textContent = "Token is required to connect to this session.";
                    statusEl.style.background = "#2d1b1b";
                    return;
                }

                const authHeaders = token
                    ? {
                          Authorization: `Bearer ${token}`,
                      }
                    : undefined;

                const wsTokenQuery = token ? `?token=${encodeURIComponent(token)}` : "";
                const wsUrl = `${wsProtocol}//${host}:${port}/ws${wsTokenQuery}`;

                const term = new Terminal({
                    cols: 120,
                    rows: 30,
                    scrollback: 5000,
                    convertEol: true,
                    allowProposedApi: true,
                    theme: {
                        background: "#1e1e1e",
                        foreground: "#ffffff",
                        cursor: "#ff80bf",
                        selectionBackground: "#ff80bf44",
                    },
                    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                    fontSize: 15,
                    cursorBlink: true,
                });

                term.open(document.getElementById("terminal"));
                term.focus();

                // Unicode11 for proper emoji/CJK character width handling
                term.loadAddon(new Unicode11Addon());
                term.unicode.activeVersion = "11";

                // Block browser's native Ctrl+C/V handling at DOM level
                document.getElementById("terminal").addEventListener("keydown", (e) => {
                    if (!e.ctrlKey) return;

                    // Ctrl+C with selection - block browser copy
                    if (e.code === "KeyC" && term.hasSelection()) {
                        e.preventDefault();
                        e.stopPropagation();
                        navigator.clipboard.writeText(term.getSelection());
                        term.clearSelection();
                        return;
                    }

                    // Ctrl+V - block browser paste
                    if (e.code === "KeyV") {
                        e.preventDefault();
                        e.stopPropagation();
                        navigator.clipboard.readText().then(text => {
                            sendViaWS(text);
                        }).catch(() => {});
                        return;
                    }
                }, true); // capture phase

                // Right-click paste (Windows Terminal style)
                document.getElementById("terminal").addEventListener("contextmenu", (e) => {
                    e.preventDefault();
                    navigator.clipboard.readText().then(text => {
                        sendViaWS(text);
                    }).catch(() => {});
                });

                // Buffered write queue to prevent escape sequence splitting
                const writeQueue = [];
                let writePending = false;

                const safeWrite = (data) => {
                    writeQueue.push(data);
                    if (!writePending) {
                        processWriteQueue();
                    }
                };

                const processWriteQueue = () => {
                    if (writeQueue.length === 0) {
                        writePending = false;
                        return;
                    }
                    writePending = true;
                    const combined = writeQueue.join('');
                    writeQueue.length = 0;
                    term.write(combined, () => {
                        if (writeQueue.length > 0) {
                            processWriteQueue();
                        } else {
                            writePending = false;
                        }
                    });
                };

                // Handle Ctrl+Enter and Shift+Enter (keys xterm doesn't emit by default)
                term.attachCustomKeyEventHandler((event) => {
                    if (event.type !== "keydown") return true;

                    // Ctrl+Enter
                    if (event.ctrlKey && event.key === "Enter") {
                        sendViaWS("\x1b[13;5u");
                        return false;
                    }

                    // Shift+Enter
                    if (event.shiftKey && event.key === "Enter" && !event.ctrlKey) {
                        sendViaWS("\x1b[13;2u");
                        return false;
                    }

                    return true;
                });

                // Resize handling
                const terminalEl = document.getElementById("terminal");
                let resizeTimeout = null;
                const handleResize = () => {
                    if (resizeTimeout) clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        const dims = term._core._renderService.dimensions;
                        if (!dims) return;
                        const charWidth = dims.css.cell.width;
                        const charHeight = dims.css.cell.height;
                        const rect = terminalEl.getBoundingClientRect();
                        const newCols = Math.floor(rect.width / charWidth);
                        const newRows = Math.floor(rect.height / charHeight);
                        if (newCols > 0 && newRows > 0 && (newCols !== term.cols || newRows !== term.rows)) {
                            term.resize(newCols, newRows);
                            const opts = { method: "POST" };
                            if (authHeaders) opts.headers = authHeaders;
                            fetch(`${httpBaseUrl}/resize?rows=${newRows}&cols=${newCols}`, opts).catch(() => {});
                        }
                    }, 100);
                };
                const resizeObserver = new ResizeObserver(handleResize);
                resizeObserver.observe(terminalEl);

                const socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    statusEl.textContent = "Connected!";
                    statusEl.style.background = "#1b2d1e";
                    socket.send(JSON.stringify({ event: "load_history" }));
                };

                socket.onmessage = event => {
                    try {
                        const msg = JSON.parse(event.data);
                        if (msg.event === "history") {
                            term.clear();
                            if (msg.data) {
                                safeWrite(msg.data);
                            }
                            return;
                        }
                        if (msg.event === "update") {
                            safeWrite(msg.data);
                        }
                    } catch (e) {
                        safeWrite(event.data);
                    }
                };

                socket.onclose = () => {
                    statusEl.textContent = "Connection closed :(";
                    statusEl.style.background = "#2d1b1b";
                    term.write("\r\n\r\n--- WebSocket closed ---\r\n");
                };

                socket.onerror = err => {
                    statusEl.textContent = "Connection error :(";
                    statusEl.style.background = "#2d1b1b";
                    console.error("WebSocket error:", err);
                };

                const sendViaWS = text => {
                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ event: "type", text, nonewline: true }));
                    }
                };

                term.onData(data => {
                    sendViaWS(data);
                });

                const ctrlcBtn = document.getElementById("ctrlc-btn");
                if (ctrlcBtn) {
                    ctrlcBtn.addEventListener("click", () => {
                        sendViaWS("\x03");
                    });
                }

                const ctrldBtn = document.getElementById("ctrld-btn");
                if (ctrldBtn) {
                    ctrldBtn.addEventListener("click", () => {
                        sendViaWS("\x04");
                    });
                }

                document.querySelectorAll(".arrow-btn").forEach(btn => {
                    btn.addEventListener("click", () => {
                        const key = btn.dataset.key;
                        const keyMap = {
                            up: "\x1b[A",
                            down: "\x1b[B",
                            left: "\x1b[D",
                            right: "\x1b[C",
                        };
                        sendViaWS(keyMap[key]);
                    });
                });

                const clearBtn = document.getElementById("clear-btn");
                if (clearBtn) {
                    clearBtn.addEventListener("click", async () => {
                        try {
                            const clearOptions = { method: "POST" };
                            if (authHeaders) {
                                clearOptions.headers = authHeaders;
                            }
                            await fetch(`${httpBaseUrl}/clear`, clearOptions);
                            term.clear();
                        } catch (e) {
                            console.error("Clear failed:", e);
                        }
                    });
                }
            })();
        </script>
    </body>
</html>
